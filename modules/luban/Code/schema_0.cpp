
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#include "schema.h"

namespace cfg {


bool attr::ActorBaseAttr::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readString(key)) return false;
    if(!_buf.readString(desc)) return false;
    if(!_buf.readInt(STR)) return false;
    if(!_buf.readInt(CON)) return false;
    if(!_buf.readInt(AGI)) return false;
    if(!_buf.readInt(WIL)) return false;
    if(!_buf.readInt(INT)) return false;

    return true;
}

bool attr::ActorBaseAttr::deserializeActorBaseAttr(::luban::ByteBuf& _buf, ::luban::SharedPtr<attr::ActorBaseAttr>& _out)
{
    _out.reset(LUBAN_NEW(attr::ActorBaseAttr));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool attr::BaseAttr::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readString(key)) return false;
    if(!_buf.readString(name)) return false;
    if(!_buf.readString(desc)) return false;
    if(!_buf.readFloat(HP)) return false;
    if(!_buf.readFloat(MP)) return false;
    if(!_buf.readFloat(ATKp)) return false;
    if(!_buf.readFloat(ATKm)) return false;
    if(!_buf.readFloat(DEFp)) return false;
    if(!_buf.readFloat(DEFm)) return false;
    if(!_buf.readFloat(SPD)) return false;
    if(!_buf.readFloat(PenP)) return false;
    if(!_buf.readFloat(PenM)) return false;
    if(!_buf.readFloat(HIT)) return false;
    if(!_buf.readFloat(EVA)) return false;
    if(!_buf.readFloat(CR)) return false;
    if(!_buf.readFloat(CD)) return false;
    if(!_buf.readFloat(PAR)) return false;
    if(!_buf.readFloat(PDR)) return false;
    if(!_buf.readFloat(CTR)) return false;
    if(!_buf.readFloat(RES)) return false;

    return true;
}

bool attr::BaseAttr::deserializeBaseAttr(::luban::ByteBuf& _buf, ::luban::SharedPtr<attr::BaseAttr>& _out)
{
    _out.reset(LUBAN_NEW(attr::BaseAttr));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool item::Item::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    if(!_buf.readString(name)) return false;
    if(!_buf.readString(desc)) return false;
    if(!_buf.readInt(count)) return false;

    return true;
}

bool item::Item::deserializeItem(::luban::ByteBuf& _buf, ::luban::SharedPtr<item::Item>& _out)
{
    _out.reset(LUBAN_NEW(item::Item));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool vector2::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readFloat(x)) return false;
    if(!_buf.readFloat(y)) return false;

    return true;
}

bool vector2::deserializevector2(::luban::ByteBuf& _buf, ::luban::SharedPtr<vector2>& _out)
{
    _out.reset(LUBAN_NEW(vector2));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool vector2i::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(x)) return false;
    if(!_buf.readInt(y)) return false;

    return true;
}

bool vector2i::deserializevector2i(::luban::ByteBuf& _buf, ::luban::SharedPtr<vector2i>& _out)
{
    _out.reset(LUBAN_NEW(vector2i));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool vector3::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readFloat(x)) return false;
    if(!_buf.readFloat(y)) return false;
    if(!_buf.readFloat(z)) return false;

    return true;
}

bool vector3::deserializevector3(::luban::ByteBuf& _buf, ::luban::SharedPtr<vector3>& _out)
{
    _out.reset(LUBAN_NEW(vector3));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool vector4::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readFloat(x)) return false;
    if(!_buf.readFloat(y)) return false;
    if(!_buf.readFloat(z)) return false;
    if(!_buf.readFloat(w)) return false;

    return true;
}

bool vector4::deserializevector4(::luban::ByteBuf& _buf, ::luban::SharedPtr<vector4>& _out)
{
    _out.reset(LUBAN_NEW(vector4));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}

}

