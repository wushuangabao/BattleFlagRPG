
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma once
#include <functional>
#include <algorithm>

#include "../CfgBean.h"

namespace cfg {

 
    enum class SkillType_NeiWai
    {
        /// <summary>
        /// 内功
        /// </summary>
        NEI = 0,
        /// <summary>
        /// 外功
        /// </summary>
        WAI = 1,
    };

 


 
    enum class SkillType_Weapon
    {
        /// <summary>
        /// 拳法
        /// </summary>
        QUAN = 0,
        /// <summary>
        /// 腿法
        /// </summary>
        TUI = 1,
        /// <summary>
        /// 剑法
        /// </summary>
        JIAN = 2,
        /// <summary>
        /// 刀法
        /// </summary>
        DAO = 3,
        /// <summary>
        /// 暗器
        /// </summary>
        AN = 4,
        /// <summary>
        /// 内功
        /// </summary>
        NEI = 5,
    };

 


namespace attr { struct ActorBaseAttr; }
namespace attr { struct BaseAttr; }
namespace item { struct Item; }
 struct vector2; 
 struct vector2i; 
 struct vector3; 
 struct vector4; 

namespace attr {

struct ActorBaseAttr : public luban::CfgBean 
{
    static bool deserializeActorBaseAttr(::luban::ByteBuf& _buf, ::luban::SharedPtr<ActorBaseAttr>& _out);

    virtual ~ActorBaseAttr() {}

    bool deserialize(::luban::ByteBuf& _buf);

    /**
     * 名字（唯一标识）
     */
    ::luban::String key;
    /**
     * 描述
     */
    ::luban::String desc;
    /**
     * 气力
     */
    ::luban::int32 STR;
    /**
     * 根骨
     */
    ::luban::int32 CON;
    /**
     * 身法
     */
    ::luban::int32 AGI;
    /**
     * 定力
     */
    ::luban::int32 WIL;
    /**
     * 悟性
     */
    ::luban::int32 INT;

    static constexpr int __ID__ = 1745311770;

    int getTypeId() const override { return __ID__; }
};

}

namespace attr {

struct BaseAttr : public luban::CfgBean 
{
    static bool deserializeBaseAttr(::luban::ByteBuf& _buf, ::luban::SharedPtr<BaseAttr>& _out);

    virtual ~BaseAttr() {}

    bool deserialize(::luban::ByteBuf& _buf);

    /**
     * 属性唯一标识
     */
    ::luban::String key;
    /**
     * 名称
     */
    ::luban::String name;
    /**
     * 描述
     */
    ::luban::String desc;
    /**
     * 气血
     */
    ::luban::float32 HP;
    /**
     * 真气/内力
     */
    ::luban::float32 MP;
    /**
     * 外攻
     */
    ::luban::float32 ATKp;
    /**
     * 内攻
     */
    ::luban::float32 ATKm;
    /**
     * 外防
     */
    ::luban::float32 DEFp;
    /**
     * 内防
     */
    ::luban::float32 DEFm;
    /**
     * 行动速度
     */
    ::luban::float32 SPD;
    /**
     * 破甲
     */
    ::luban::float32 PenP;
    /**
     * 破气
     */
    ::luban::float32 PenM;
    /**
     * 命中率
     */
    ::luban::float32 HIT;
    /**
     * 闪避率
     */
    ::luban::float32 EVA;
    /**
     * 暴击率
     */
    ::luban::float32 CR;
    /**
     * 暴击伤害倍数
     */
    ::luban::float32 CD;
    /**
     * 招架/格挡率
     */
    ::luban::float32 PAR;
    /**
     * 招架减伤
     */
    ::luban::float32 PDR;
    /**
     * 反击率
     */
    ::luban::float32 CTR;
    /**
     * 异常抗性
     */
    ::luban::float32 RES;

    static constexpr int __ID__ = 1576771551;

    int getTypeId() const override { return __ID__; }
};

}

namespace item {

struct Item : public luban::CfgBean 
{
    static bool deserializeItem(::luban::ByteBuf& _buf, ::luban::SharedPtr<Item>& _out);

    virtual ~Item() {}

    bool deserialize(::luban::ByteBuf& _buf);

    /**
     * id
     */
    ::luban::int32 id;
    /**
     * 名称
     */
    ::luban::String name;
    /**
     * 描述
     */
    ::luban::String desc;
    /**
     * 个数
     */
    ::luban::int32 count;

    static constexpr int __ID__ = 2107285806;

    int getTypeId() const override { return __ID__; }
};

}



struct vector2 : public luban::CfgBean 
{
    static bool deserializevector2(::luban::ByteBuf& _buf, ::luban::SharedPtr<vector2>& _out);

    virtual ~vector2() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 x;
    ::luban::float32 y;

    static constexpr int __ID__ = 337790799;

    int getTypeId() const override { return __ID__; }
};





struct vector2i : public luban::CfgBean 
{
    static bool deserializevector2i(::luban::ByteBuf& _buf, ::luban::SharedPtr<vector2i>& _out);

    virtual ~vector2i() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 x;
    ::luban::int32 y;

    static constexpr int __ID__ = 1881580282;

    int getTypeId() const override { return __ID__; }
};





struct vector3 : public luban::CfgBean 
{
    static bool deserializevector3(::luban::ByteBuf& _buf, ::luban::SharedPtr<vector3>& _out);

    virtual ~vector3() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 x;
    ::luban::float32 y;
    ::luban::float32 z;

    static constexpr int __ID__ = 337790800;

    int getTypeId() const override { return __ID__; }
};





struct vector4 : public luban::CfgBean 
{
    static bool deserializevector4(::luban::ByteBuf& _buf, ::luban::SharedPtr<vector4>& _out);

    virtual ~vector4() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 x;
    ::luban::float32 y;
    ::luban::float32 z;
    ::luban::float32 w;

    static constexpr int __ID__ = 337790801;

    int getTypeId() const override { return __ID__; }
};



namespace item {


class TbItem
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<item::Item>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<item::Item>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<item::Item> _v;
            if(!item::Item::deserializeItem(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<item::Item>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<item::Item>>& getDataList() const { return _dataList; }

    item::Item* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<item::Item> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace attr {


class TbActorBaseAttr
{
    private:
    ::luban::HashMap<::luban::String, ::luban::SharedPtr<attr::ActorBaseAttr>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<attr::ActorBaseAttr>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<attr::ActorBaseAttr> _v;
            if(!attr::ActorBaseAttr::deserializeActorBaseAttr(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->key] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::String, ::luban::SharedPtr<attr::ActorBaseAttr>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<attr::ActorBaseAttr>>& getDataList() const { return _dataList; }

    attr::ActorBaseAttr* getRaw(::luban::String key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<attr::ActorBaseAttr> get(::luban::String key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace attr {


class TbBaseAttr
{
    private:
    ::luban::HashMap<::luban::String, ::luban::SharedPtr<attr::BaseAttr>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<attr::BaseAttr>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<attr::BaseAttr> _v;
            if(!attr::BaseAttr::deserializeBaseAttr(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->key] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::String, ::luban::SharedPtr<attr::BaseAttr>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<attr::BaseAttr>>& getDataList() const { return _dataList; }

    attr::BaseAttr* getRaw(::luban::String key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<attr::BaseAttr> get(::luban::String key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

class Tables
{
    public:
     item::TbItem TbItem;
     attr::TbActorBaseAttr TbActorBaseAttr;
     attr::TbBaseAttr TbBaseAttr;

    bool load(::luban::Loader<::luban::ByteBuf> loader)
    {
        ::luban::ByteBuf buf;
        buf.clear();
        if (!loader(buf, "item_tbitem")) return false;
        if (!TbItem.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "attr_tbactorbaseattr")) return false;
        if (!TbActorBaseAttr.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "attr_tbbaseattr")) return false;
        if (!TbBaseAttr.load(buf)) return false;
        return true;
    }
};



}

